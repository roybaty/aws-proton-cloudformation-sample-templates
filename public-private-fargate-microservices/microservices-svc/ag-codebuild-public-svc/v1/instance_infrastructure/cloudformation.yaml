AWSTemplateFormatVersion: '2010-09-09'
Description: Deploy a service on AWS Fargate, hosted in a public subnet, and accessible via a public load balancer.
Mappings:
  EnvironmentNameConfig:
    Environment:
      Name: '{{environment.name}}'
  TaskSize:
    x-small:
      cpu: 256
      memory: 512
    small:
      cpu: 512
      memory: 1024
    medium:
      cpu: 1024
      memory: 2048
    large:
      cpu: 2048
      memory: 4096
    x-large:
      cpu: 4096
      memory: 8192

Resources:
  # ECS Service and Task "
  # Register service in ServiceDiscovery Service
  DiscoveryService:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Description: Discovery Service for the Demo Application
      DnsConfig:
        RoutingPolicy: MULTIVALUE
        DnsRecords:
          - TTL: 60
            Type: A
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: '{{service_instance.inputs.service_discovery_name}}'
      NamespaceId: '{{environment.outputs.PrivateNamespace}}'

  # A log group for storing the stdout logs from this service's containers
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: '{{service.name}}/{{service_instance.name}}'

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: '{{service.name}}_{{service_instance.name}}'
      Cpu: !FindInMap [TaskSize, {{service_instance.inputs.task_size}}, cpu]
      Memory: !FindInMap [TaskSize, {{service_instance.inputs.task_size}}, memory]
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: '{{environment.outputs.ECSTaskExecutionRole}}'
      TaskRoleArn: !Ref "AWS::NoValue"
      ContainerDefinitions:
        - Name: '{{service_instance.name}}'
          Cpu: !FindInMap [TaskSize, {{service_instance.inputs.task_size}}, cpu]
          Memory: !FindInMap [TaskSize, {{service_instance.inputs.task_size}}, memory]
          Image: '{{service_instance.inputs.image}}'
          PortMappings:
            - ContainerPort: '{{service_instance.inputs.port}}'
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: '{{service.name}}/{{service_instance.name}}'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: '{{service.name}}/{{service_instance.name}}'
      Tags:
        - Key: Name
          Value: !FindInMap ['EnvironmentNameConfig', 'Environment', 'Name']

  # The service_instance.inputs. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  Service:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName: '{{service.name}}_{{service_instance.name}}'
      Cluster: '{{environment.outputs.ClusterName}}'
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: '{{service_instance.inputs.desired_count}}'
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - '{{environment.outputs.ContainerSecurityGroup}}'
          Subnets:
            - '{{environment.outputs.PublicSubnetOne}}'
            - '{{environment.outputs.PublicSubnetTwo}}'
      TaskDefinition: !Ref 'TaskDefinition'
      ServiceRegistries:
      - RegistryArn: !GetAtt DiscoveryService.Arn
      LoadBalancers:
        - ContainerName: '{{service_instance.name}}'
          ContainerPort: '{{service_instance.inputs.port}}'
          TargetGroupArn: !Ref 'TargetGroup'
      Tags:
        - Key: Name
          Value: !FindInMap ['EnvironmentNameConfig', 'Environment', 'Name']

  # A target group. This is used for keeping track of all the tasks, and
  # what IP addresses / port numbers they have. You can query it yourself,
  # to use the addresses yourself, but most often this target group is just
  # connected to an application load balancer, or network load balancer, so
  # it can automatically distribute traffic across all the targets.
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      TargetType: ip
      # Note that the Name property has a 32 character limit, which could be
      # reached by using either {{service.name}}, {{service_instance.name}}
      # or a combination of both as we're doing here, so we truncate the name to 29 characters
      # plus an ellipsis different from '...' or '---' to avoid running into errors.
      Name: '{{ (service.name ~ "--" ~ service_instance.name) | truncate(29, True, end="zzz", leeway=0) }}'
      Port: '{{service_instance.inputs.port}}'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: '{{environment.outputs.VpcId}}'
      Tags:
        - Key: Name
          Value: !FindInMap ['EnvironmentNameConfig', 'Environment', 'Name']

  # Create a rule on the load balancer for routing traffic to the target group
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'TargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values:
            - '*'
      ListenerArn: !Ref PublicLoadBalancerListener
      Priority: 1

  # Enable autoscaling for this service
  ScalableTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    DependsOn: Service
    Properties:
      ServiceNamespace: 'ecs'
      ScalableDimension: 'ecs:service:DesiredCount'
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - '{{environment.outputs.ClusterName}}'
            - '{{service.name}}_{{service_instance.name}}'
      MinCapacity: 1
      MaxCapacity: 10
      RoleARN: !Sub arn:aws:iam::${AWS::AccountId}:role/aws-service-role/ecs.application-autoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_ECSService

  # Create scaling policies for the service
  ScaleDownPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: ScalableTarget
    Properties:
      PolicyName:
        Fn::Join:
          - '/'
          - - scale
            - '{{service.name}}_{{service_instance.name}}'
            - down
      PolicyType: StepScaling
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - '{{environment.outputs.ClusterName}}'
            - '{{service.name}}_{{service_instance.name}}'
      ScalableDimension: 'ecs:service:DesiredCount'
      ServiceNamespace: 'ecs'
      StepScalingPolicyConfiguration:
        AdjustmentType: 'ChangeInCapacity'
        StepAdjustments:
          - MetricIntervalUpperBound: 0
            ScalingAdjustment: -1
        MetricAggregationType: 'Average'
        Cooldown: 60

  ScaleUpPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: ScalableTarget
    Properties:
      PolicyName:
        Fn::Join:
          - '/'
          - - scale
            - '{{service.name}}_{{service_instance.name}}'
            - up
      PolicyType: StepScaling
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - '{{environment.outputs.ClusterName}}'
            - '{{service.name}}_{{service_instance.name}}'
      ScalableDimension: 'ecs:service:DesiredCount'
      ServiceNamespace: 'ecs'
      StepScalingPolicyConfiguration:
        AdjustmentType: 'ChangeInCapacity'
        StepAdjustments:
          - MetricIntervalLowerBound: 0
            MetricIntervalUpperBound: 15
            ScalingAdjustment: 1
          - MetricIntervalLowerBound: 15
            MetricIntervalUpperBound: 25
            ScalingAdjustment: 2
          - MetricIntervalLowerBound: 25
            ScalingAdjustment: 3
        MetricAggregationType: 'Average'
        Cooldown: 60

  # Create alarms to trigger these policies
  LowCpuUsageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName:
        Fn::Join:
          - '-'
          - - low-cpu
            - '{{service.name}}_{{service_instance.name}}'
      AlarmDescription:
        Fn::Join:
          - ' '
          - - "Low CPU utilization for service"
            - '{{service.name}}_{{service_instance.name}}'
      MetricName: CPUUtilization
      Namespace: AWS/ECS
      Dimensions:
        - Name: ServiceName
          Value: '{{service.name}}_{{service_instance.name}}'
        - Name: ClusterName
          Value:
            '{{environment.outputs.ClusterName}}'
      Statistic: Average
      Period: 60
      EvaluationPeriods: 1
      Threshold: 20
      ComparisonOperator: LessThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleDownPolicy

  HighCpuUsageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName:
        Fn::Join:
          - '-'
          - - high-cpu
            - '{{service.name}}_{{service_instance.name}}'
      AlarmDescription:
        Fn::Join:
          - ' '
          - - "High CPU utilization for service"
            - '{{service.name}}_{{service_instance.name}}'
      MetricName: CPUUtilization
      Namespace: AWS/ECS
      Dimensions:
        - Name: ServiceName
          Value: '{{service.name}}_{{service_instance.name}}'
        - Name: ClusterName
          Value:
            '{{environment.outputs.ClusterName}}'
      Statistic: Average
      Period: 60
      EvaluationPeriods: 1
      Threshold: 70
      ComparisonOperator: GreaterThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleUpPolicy

  EcsSecurityGroupIngressFromPublicALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the public ALB
      GroupId: '{{environment.outputs.ContainerSecurityGroup}}'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'InternalLoadBalancerSG'

  # Public load balancer, hosted in public subnets that is accessible
  # to the public, and is intended to route traffic to one or more public
  # facing services. This is used for accepting traffic from the public
  # internet and directing it to public facing microservices
  PublicLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the public facing load balancer
      VpcId: '{{environment.outputs.VpcId}}'
      SecurityGroupIngress:
          # Allow access to ALB from anywhere on the internet
          - CidrIp: 0.0.0.0/0
            IpProtocol: -1
      Tags:
        - Key: Name
          Value: !FindInMap ['EnvironmentNameConfig', 'Environment', 'Name']

  # Load Balancer #
  PublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internal
      LoadBalancerAttributes:
      - Key: idle_timeout.timeout_seconds
        Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic
        # from the internet can reach the load balancer directly via the internet gateway
        - '{{environment.outputs.PublicSubnetOne}}'
        - '{{environment.outputs.PublicSubnetTwo}}'
      SecurityGroups:
        - !Ref InternalLoadBalancerSG
      Tags:
        - Key: Name
          Value: !FindInMap ['EnvironmentNameConfig', 'Environment', 'Name']

  PublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PublicLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'TargetGroup'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PublicLoadBalancer'
      Port: 80
      Protocol: HTTP

# Internal Security groups for load balancer
  ApiGatewayVpcLinkSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow API GW VPC Link to reach the internal ALB
      VpcId: '{{ environment.outputs.VpcId }}'
      # No ingress needed on the VPC Link ENIs; ALB initiates nothing to them.
      # Egress to ALB (all) - you can narrow to ALB SG + port 80 later if desired.
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-apigw-vpclink-sg"

# Internal ALB SG (replaces PublicLoadBalancerSG)
  InternalLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Internal access to the load balancer from API Gateway VPC Link
      VpcId: '{{ environment.outputs.VpcId }}'
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0   # TEMP to validate the path
          # SourceSecurityGroupId: !Ref ApiGatewayVpcLinkSG
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-alb-internal-sg"

  # API Gateway #      
  # API Gateway HTTP API (proxy everything to ALB via VPC Link)
  HttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub "${AWS::StackName}-httpapi"
      ProtocolType: HTTP

  ApiVpcLink:
    Type: AWS::ApiGatewayV2::VpcLink
    Properties:
      Name: !Sub "${AWS::StackName}-vpclink"
      SubnetIds:
        - '{{ environment.outputs.PublicSubnetOne }}'
        - '{{ environment.outputs.PublicSubnetTwo }}'
      SecurityGroupIds:
        - !Ref ApiGatewayVpcLinkSG

  # Integration: HTTP proxy to the ALB listener
  HttpApiIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: HTTP_PROXY
      IntegrationMethod: ANY
      ConnectionType: VPC_LINK
      ConnectionId: !Ref ApiVpcLink
      IntegrationUri: !Ref PublicLoadBalancerListener   # listener ARN
      PayloadFormatVersion: "1.0"
      RequestParameters:
        "overwrite:path": "$request.path"

  # Route: proxy all paths and methods to the integration
  HttpApiProxyRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "ANY /{proxy+}"
      Target: !Sub "integrations/${HttpApiIntegration}"

  HttpApiDefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "$default"
      Target: !Sub "integrations/${HttpApiIntegration}"

  # Stage: auto-deploy on change
  HttpApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref HttpApi
      StageName: "{{ environment.name | lower }}"
      AutoDeploy: true
      {% if service_instance.inputs.api_enable_throttling | default(false) %}
      DefaultRouteSettings:
        ThrottlingBurstLimit: {{ service_instance.inputs.api_throttling_burst }}
        ThrottlingRateLimit:  {{ service_instance.inputs.api_throttling_rate }}
      {% endif %}

  # Code Build #
  # Role used by CodeBuild to call Proton/ECR/Logs
  InstanceDeployProjectRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: codebuild.amazonaws.com }
            Action: sts:AssumeRole
      Policies:
        - PolicyName: DeployPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"
              - Effect: Allow
                Action:
                  - ecr:DescribeImages
                  - sts:GetCallerIdentity
                Resource: "*"
              - Effect: Allow
                Action:
                  - proton:GetService
                  - proton:GetServiceInstance
                  - proton:UpdateServiceInstance
                Resource: "*"

  # Create BuildBuild project to update aws proton
  InstanceDeployProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub "proton-${AWS::StackName}-deploy"
      ServiceRole: !GetAtt InstanceDeployProjectRole.Arn
      Artifacts: { Type: NO_ARTIFACTS }
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: false
        EnvironmentVariables:
          # These act as defaults; EventBridge will override them dynamically.
          - Name: PROTON_SERVICE
            Type: PLAINTEXT
            Value: "{{ service.name }}"
          - Name: PROTON_INSTANCE
            Type: PLAINTEXT
            Value: "{{ service_instance.name }}"
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          env:
            shell: bash
          phases:
            install:
              commands:
                - |
                  set -eo pipefail
                  apt-get update -y && apt-get install -y jq
                  curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
                  chmod +x /usr/local/bin/yq
            build:
              commands:
                - |
                  set -eo pipefail
                  test -n "$ECR_TAG" || ECR_TAG=latest
                  ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
                  echo "Using account_id=$ACCOUNT_ID repo=$ECR_REPO tag=$ECR_TAG region=$AWS_DEFAULT_REGION"
                  DIGEST=$(aws ecr describe-images --repository-name "$ECR_REPO" --image-ids imageTag="$ECR_TAG" --query 'imageDetails[0].imageDigest' --output text)
                  test "$DIGEST" != "None" || { echo "Tag '$ECR_TAG' not found in ECR repo '$ECR_REPO'"; exit 1; }
                  IMAGE_URI="$ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPO@$DIGEST"
                  echo "Deploying $IMAGE_URI to service=$PROTON_SERVICE instance=$PROTON_INSTANCE"
                  aws proton get-service --name "$PROTON_SERVICE" | jq -r .service.spec > service.yaml
                  yq e 'keys' service.yaml
                  yq -i '(.instances[] | select(.name == env(PROTON_INSTANCE)) | .spec.image) = env(IMAGE_URI)' service.yaml
                  aws proton update-service-instance --deployment-type CURRENT_VERSION --name "$PROTON_INSTANCE" --service-name "$PROTON_SERVICE" --spec file://service.yaml
                  aws proton wait service-instance-deployed --name "$PROTON_INSTANCE" --service-name "$PROTON_SERVICE"
  # EventBridge rule: fire CodeBuild on ANY successful ECR push (any repo/tag)
  EcrPushRule:
    Type: AWS::Events::Rule
    Properties:
      Description: !Sub "Trigger deploy for ${AWS::StackName} on ANY ECR push"
      EventPattern:
        source: ["aws.ecr", "myver.sim.ecr"]
        detail-type: ["ECR Image Action"]
        detail:
          action-type: ["PUSH"]
          result: ["SUCCESS"]
          # No repository-name / image-tag filter -> catch all
      Targets:
        - Id: StartDeployBuild
          Arn: !GetAtt InstanceDeployProject.Arn
          RoleArn: !GetAtt EventsInvokeCodeBuildRole.Arn
          InputTransformer:
            InputPathsMap:
              repo: "$.detail.repository-name"
              tag: "$.detail.image-tag"
            InputTemplate: |
              {
                "environmentVariablesOverride": [
                  { "name": "ECR_REPO", "type": "PLAINTEXT", "value": <repo> },
                  { "name": "ECR_TAG",  "type": "PLAINTEXT", "value": <tag> }
                ]
              }

  # Role that Events uses to start CodeBuild
  EventsInvokeCodeBuildRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: events.amazonaws.com }
            Action: sts:AssumeRole
      Policies:
        - PolicyName: StartBuild
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: codebuild:StartBuild
                Resource: !GetAtt InstanceDeployProject.Arn


# Outputs
Outputs:
  ServiceDiscovery:
    Description: The registered service discovery Service Id
    Value: !Ref DiscoveryService
  ApiGatewayInvokeUrl:
    Description: HTTP API base URL (no custom domain yet)
    Value: !Sub "https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com/{{ environment.name | lower }}/"
